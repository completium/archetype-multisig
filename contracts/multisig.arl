/**
 * Generic multisig contract
 */
archetype multisig(
  owner        : address,
  required     : nat,
  max_duration : duration,
  min_duration : duration
)

//----------------------------------------------------------------------------
// Errors
//----------------------------------------------------------------------------

constant EXPIRED_PROPOSAL    : string = "EXPIRED_PROPOSAL"
constant NOT_APPROVED        : string = "NOT_APPROVED"
constant INVALID_SIGNATURE   : string = "INVALID_SIGNATURE"
constant WRONG_DURATION      : string = "WRONG_DURATION"
constant CONTRACT_PAUSED     : string = "CONTRACT_PAUSED"
constant CONTRACT_NOT_PAUSED : string = "CONTRACT_NOT_PAUSED"

//----------------------------------------------------------------------------
// Assets
//----------------------------------------------------------------------------

variable id_count : nat = 0
asset manager {
  addr    : address;
  counter : nat = 0  // protects from double-spending attack
}

asset pending to big_map {
  id         : nat;
  expiration : date;
  approvals  : set<address>;
  actions    : lambda<unit, list<operation>>;
}

//----------------------------------------------------------------------------
// States
//----------------------------------------------------------------------------

states = 
| Starting initial
| Running
| Paused

//----------------------------------------------------------------------------
// Owner role transfer
//----------------------------------------------------------------------------

variable owner_candidate : option<address> = none

entry declare_ownership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claim_ownership() {
  called by opt_get(owner_candidate)
  effect {
    owner := opt_get(owner_candidate);
    owner_candidate := none
  }
}

//----------------------------------------------------------------------------
// Metadata
//----------------------------------------------------------------------------

entry set_metadata_uri(idata : bytes) {
  called by owner
  effect {
    metadata := put(metadata, "", idata)
  }
}

//----------------------------------------------------------------------------
// Contract execution pause/resume
//----------------------------------------------------------------------------

transition pause() {
  called by owner
  from Running to Paused
}

transition unpause() {
  called by owner
  from Paused to Running
}

//----------------------------------------------------------------------------
// Control entry to add / remove a manager
// May be called in Starting or Running states
//----------------------------------------------------------------------------

entry control(maddr : address, allowed : bool) {
  called by owner
  //state is Starting or Running
  require {
    r4 : allowed <> manager.contains(maddr)
  }
  effect {
    if allowed then
      manager.add({ addr = maddr })
    else
      manager.remove(maddr)
  }
}

//----------------------------------------------------------------------------
// Transition to Running state
// owner becomes selfaddress 
//----------------------------------------------------------------------------

transition run() {
  called by owner
  require {
    r0 : manager.count() > required 
  }
  from Starting to Running
  with effect {
    owner := selfaddress
  }
}

//----------------------------------------------------------------------------
// Set parameters in Running state 
//----------------------------------------------------------------------------

entry %require(new_required : nat) {
  called by owner
  state is Running
  require {
    r7 : 0 < new_required <= manager.count()
  }
  effect {
    required := new_required
  }
}

entry execute(proposal_id : nat) {
  state is Running
  require {
    r1 : pending[proposal_id].expiration >= now otherwise EXPIRED_PROPOSAL;
    r2 : length(pending[proposal_id].approvals) >= required otherwise NOT_APPROVED
  }
  effect {
    operations := exec_lambda(pending[proposal_id].actions, Unit);
    pending.remove(proposal_id)
  }
}

entry execute_feeless(proposal_id : nat, manager_key : key, s : signature) {
  state is Running
  require {
    r5 : pending[proposal_id].expiration >= now otherwise EXPIRED_PROPOSAL;
    r6 : length(pending[proposal_id].approvals) >= required otherwise NOT_APPROVED
  }
  effect {
    var pkh = key_address(manager_key);
    dorequire(check_signature(manager_key, s, pack((pkh, manager[pkh].counter, "execute", proposal_id))), INVALID_SIGNATURE);
    manager[pkh].counter += 1;
    operations := exec_lambda(pending[proposal_id].actions, Unit);
    pending.remove(proposal_id);
  }
}

entry approve(proposal_id : nat) {
  called by manager
  state is Running
  effect {
    if pending[proposal_id].expiration < now then
      pending.remove(proposal_id)
    else
      pending[proposal_id].approvals.add(caller)
  }
}

entry approve_feeless(proposal_id : nat, manager_key : key, s : signature) {
  state is Running
  effect {
    var pkh = key_address(manager_key);
    dorequire(check_signature(manager_key, s, pack((pkh, manager[pkh].counter, "approve", proposal_id))), INVALID_SIGNATURE);
    manager[pkh].counter += 1;
    if pending[proposal_id].expiration < now then
      pending.remove(proposal_id)
    else
      pending[proposal_id].approvals.add(pkh)
  }
}

entry propose(
  actions_to_exec : lambda<unit, list<operation>>,
  expiration_duration : duration,
  approved_by_caller : bool) {
  called by manager
  state is Running
  require {
    r3 : min_duration <= expiration_duration <= max_duration otherwise WRONG_DURATION
  }
  effect {
    var init_approvals : set<address> = [];
    if approved_by_caller then
      init_approvals.add(caller);
    pending.add({
      id_count;
      (now + expiration_duration);
      init_approvals;
      actions_to_exec
    });
    id_count += 1;
  }
}

//----------------------------------------------------------------------------
// Getters (aka TZIP4 view)
//----------------------------------------------------------------------------

getter get_manager_counter(pkh : address) : nat {
  return (if manager.contains(pkh) then manager[pkh].counter else 0)
}

getter get_approvals(proposal_id : nat) : set<address> {
  var empty : set<address> = [];
  return (if pending.contains(proposal_id) then pending[proposal_id].approvals else empty)
}
