archetype multisig(owner : address)

variable required : nat = 5
variable id_count : nat = 0

variable max_duration : duration = 180d
variable min_duration : duration = 1h

constant NOT_APPROVED      : string = "NOT_APPROVED"
constant INVALID_SIGNATURE : string = "INVALID_SIGNATURE"
constant WRONG_DURATION    : string = "WRONG_DURATION"

asset manager {
  addr    : address;
  counter : nat = 0  // protects from double-spending attack
}

asset pending to big_map {
  id      : nat;
  expired : date;
  //approvals : set<pkey<manager>>;
  approvals : set<address>;
  actions   : lambda<unit, list<operation>>;
}

entry execute(proposal_id : nat) {
  called by manager
  require {
    r0 : pending[proposal_id].expired < now;
    r1 : length(pending[proposal_id].approvals) >= required otherwise NOT_APPROVED
  }
  effect {
    operations := exec_lambda(pending[proposal_id].actions, Unit);
    pending.remove(proposal_id)
  }
}

entry execute_feeless(proposal_id : nat, manager_key : key, s : signature) {
  require {
    r5 : now < pending[proposal_id].expired;
    r6 : length(pending[proposal_id].approvals) >= required otherwise NOT_APPROVED;
  }
  effect {
    var pkh = key_address(manager_key);
    dorequire(check_signature(manager_key, s, pack((pkh, manager[pkh].counter, "execute", proposal_id))), INVALID_SIGNATURE);
    manager[pkh].counter += 1;
    operations := exec_lambda(pending[proposal_id].actions, Unit);
    pending.remove(proposal_id);
  }
}

entry approve(proposal_id : nat) {
  called by manager
  effect {
    if pending[proposal_id].expired < now then
      pending.remove(proposal_id)
    else
      pending[proposal_id].approvals.add(caller)
  }
}

entry approve_feeless(proposal_id : nat, manager_key : key, s : signature) {
  var pkh = key_address(manager_key);
  dorequire(check_signature(manager_key, s, pack((pkh, manager[pkh].counter, "approve", proposal_id))), INVALID_SIGNATURE);
  manager[pkh].counter += 1;
  if pending[proposal_id].expired < now then
    pending.remove(proposal_id)
  else
    pending[proposal_id].approvals.add(pkh)
}

entry propose(
  actions_to_exec : lambda<unit, list<operation>>,
  expired_duration : duration,
  approved_by_caller : bool) {
  called by manager
  require {
    r2 : min_duration <= expired_duration <= max_duration otherwise WRONG_DURATION
  }
  effect {
    var init_approvals : set<address> = [];
    if approved_by_caller then
      init_approvals.add(caller);
    pending.add({
      id_count;
      (now + expired_duration);
      init_approvals;
      actions_to_exec
    });
    id_count += 1;
  }
}

entry control(maddr : address, allowed : bool) {
  called by owner
  require {
    r3 : allowed <> manager.contains(maddr)
  }
  effect {
    if allowed then
      manager.add({ addr = maddr })
    else
      manager.remove(maddr)
  }
}

entry %require(new_required : nat) {
  called by owner
  require {
    r4 : 0 < new_required <= manager.count()
  }
  effect {
    required := new_required
  }
}

getter getManagerCounter(pkh : address) : nat {
  return (if manager.contains(pkh) then manager[pkh].counter else 0)
}
